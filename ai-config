#!/bin/bash

# AI-Config: Unified AI Tools Configuration Manager
# https://github.com/nanxiaobei/ai-config

set -e

CONFIG_DIR="$HOME/.ai-config"
KNOWN_TOOLS_FILE="$CONFIG_DIR/.known-tools"
BACKUP_DIR="$CONFIG_DIR/backups"
INSTRUCTIONS_MD="$CONFIG_DIR/instructions.md"
SKILLS_DIR="$CONFIG_DIR/skills"
AGENTS_DIR="$CONFIG_DIR/agents"
RULES_DIR="$CONFIG_DIR/rules"
COMMANDS_DIR="$CONFIG_DIR/commands"
PROMPTS_DIR="$CONFIG_DIR/prompts"

# Version (read from package.json)
# Prefer node for correct JSON parsing; fallback to grep/sed; finally fallback to a default.
VERSION=""
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PACKAGE_JSON="$SCRIPT_DIR/package.json"

if [[ -f "$PACKAGE_JSON" ]]; then
    if command -v node >/dev/null 2>&1; then
        VERSION=$(node -p "try{require(process.env.PACKAGE_JSON).version||''}catch(e){''}" 2>/dev/null PACKAGE_JSON="$PACKAGE_JSON")
    fi

    if [[ -z "$VERSION" ]]; then
        VERSION=$(grep '"version"' "$PACKAGE_JSON" 2>/dev/null | head -1 | sed 's/.*"version": *"\([^"]*\)".*/\1/')
    fi
fi

VERSION=${VERSION:-""}

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m'

log_info() { echo -e "${BLUE}[INFO]${NC} $1"; }
log_ok() { echo -e "${GREEN}[OK]${NC} $1"; }
log_warn() { echo -e "${YELLOW}[WARN]${NC} $1"; }
log_error() { echo -e "${RED}[ERROR]${NC} $1"; }

# Known AI tool patterns
# Format: dir|name|instr_file|skills_dir|agents_dir|rules_dir|commands_dir|prompts_dir
declare -a KNOWN_PATTERNS=(
    ".claude|Claude Code|CLAUDE.md|skills|.|.|commands|."
    ".cursor|Cursor|rules/global.md|skills|.|.|.|prompts"
    ".factory|Factory Droid|droids/global.md|.|.|.|.|."
    ".amp|Amp|instructions.md|.|.|.|.|."
    ".antigravity|Antigravity|CLAUDE.md|skills|.|.|commands|."
    ".gemini|Gemini CLI|GEMINI.md|skills|.|.|commands|."
    ".kiro|Kiro|steering/global.md|.|agents|.|.|."
    ".opencode|OpenCode|instructions.md|.|.|.|.|."
    ".qoder|Qoder|instructions.md|.|.|.|.|."
    ".qodo|Qodo|instructions.md|.|agents|.|.|."
    ".config/github-copilot|GitHub Copilot|instructions.md|.|.|.|.|."
    ".aider|Aider|.aider.conf.yml|.|.|.|.|."
    ".continue|Continue|config.json|.|.|rules|.|prompts"
    ".codeium|Codeium|config.json|.|.|.|.|."
    ".tabnine|TabNine|tabnine_config.json|.|.|.|.|."
    ".sourcegraph|Sourcegraph Cody|cody.json|.|.|.|commands|."
    ".codegpt|CodeGPT|settings.json|.|.|.|.|prompts"
    ".windsurf|Windsurf|instructions.md|skills|agents|rules|.|."
    ".trae|Trae|instructions.md|.|.|.|.|."
    ".melty|Melty|instructions.md|.|.|.|.|."
    ".void|Void|instructions.md|.|.|.|.|."
    ".roo|Roo Code|instructions.md|.|.|rules|.|."
    ".zed|Zed|settings.json|.|.|.|.|."
    ".cline|Cline|instructions.md|.|.|rules|.|prompts"
    ".aide|Aide|instructions.md|.|.|.|.|."
    ".pear|PearAI|instructions.md|.|.|.|.|."
    ".supermaven|Supermaven|config.json|.|.|.|.|."
    ".codestory|CodeStory|instructions.md|.|.|.|.|."
    ".double|Double|instructions.md|.|.|.|.|."
    ".blackbox|Blackbox AI|config.json|.|.|.|.|."
    ".amazonq|Amazon Q|instructions.md|.|.|.|.|."
    ".copilot-workspace|Copilot Workspace|instructions.md|.|.|.|.|."
    ".codex|OpenAI Codex|instructions.md|.|.|.|.|."
    ".goose|Goose AI|instructions.md|.|.|.|.|."
    ".mentat|Mentat|instructions.md|.|.|.|.|."
    ".gpt-engineer|GPT Engineer|instructions.md|.|.|.|.|prompts"
    ".smol|Smol Developer|instructions.md|.|.|.|.|prompts"
    ".config/opencode|OpenCode Config|instructions.md|.|.|.|.|."
)

# Backup a file or directory
backup_item() {
    local source="$1"
    local tool_dir="$2"
    local type="$3"

    [[ ! -e "$source" ]] && return 0
    [[ -L "$source" ]] && return 0

    mkdir -p "$BACKUP_DIR"

    local backup_name=$(echo "$tool_dir" | tr '/' '_')
    local timestamp=$(date +%s)
    local backup_path="$BACKUP_DIR/${backup_name}.${type}.${timestamp}"

    if [[ -d "$source" ]]; then
        cp -r "$source" "$backup_path" 2>/dev/null || return 0
    else
        cp "$source" "$backup_path" 2>/dev/null || return 0
    fi

    log_ok "Backed up: $source"
}

# Merge items from a tool to shared directory (dedup by filename)
merge_items() {
    local source_dir="$1"
    local target_dir="$2"
    local type="$3"

    [[ ! -d "$source_dir" ]] && return
    [[ -L "$source_dir" ]] && return

    local merged_count=0

    for item in "$source_dir"/*; do
        [[ ! -e "$item" ]] && continue
        local name=$(basename "$item")
        local target="$target_dir/$name"

        [[ -e "$target" ]] && continue

        if [[ -d "$item" ]]; then
            cp -r "$item" "$target"
        else
            cp "$item" "$target"
        fi
        ((merged_count++))
    done

    if [[ $merged_count -gt 0 ]]; then
        log_ok "Merged $merged_count $type from $source_dir"
    fi
}

# Create symlink
create_symlink() {
    local source="$1"
    local target="$2"

    [[ ! -e "$source" ]] && return

    local target_dir=$(dirname "$target")
    mkdir -p "$target_dir"

    if [[ -e "$target" ]] && [[ ! -L "$target" ]]; then
        local backup="${target}.backup.$(date +%Y%m%d%H%M%S)"
        mv "$target" "$backup"
        log_warn "Backed up: $target"
    fi

    [[ -L "$target" ]] && rm "$target"
    ln -s "$source" "$target"
}

# Count files in directory
count_files() {
    local dir="$1"
    if [[ -d "$dir" ]]; then
        find "$dir" -maxdepth 1 -type f 2>/dev/null | wc -l | tr -d ' '
    else
        echo "0"
    fi
}

# Show symlink status
show_status() {
    log_info "Symlink status:"
    echo ""

    if [[ ! -f "$KNOWN_TOOLS_FILE" ]]; then
        log_info "No tools configured. Run 'ai-config' first."
        return
    fi

    echo -e "${BLUE}[instructions]${NC}"
    while IFS= read -r dir_name; do
        [[ -z "$dir_name" ]] && continue
        for pattern in "${KNOWN_PATTERNS[@]}"; do
            IFS='|' read -r known_dir tool_name instr_file skills agents rules commands prompts <<< "$pattern"
            if [[ "$dir_name" == "$known_dir" ]]; then
                if [[ "$instr_file" != "." ]] && [[ "$instr_file" != *.json ]] && [[ "$instr_file" != *.yml ]]; then
                    local target="$HOME/$dir_name/$instr_file"
                    if [[ -L "$target" ]]; then
                        echo -e "  ${GREEN}✓${NC} $target"
                    elif [[ -e "$target" ]]; then
                        echo -e "  ${YELLOW}!${NC} $target (not a symlink)"
                    else
                        echo -e "  ${RED}✗${NC} $target (missing)"
                    fi
                fi
                break
            fi
        done
    done < "$KNOWN_TOOLS_FILE"

    for type_name in skills agents rules commands prompts; do
        echo -e "\n${BLUE}[$type_name]${NC}"
        while IFS= read -r dir_name; do
            [[ -z "$dir_name" ]] && continue
            for pattern in "${KNOWN_PATTERNS[@]}"; do
                IFS='|' read -r known_dir tool_name instr_file skills agents rules commands prompts <<< "$pattern"
                if [[ "$dir_name" == "$known_dir" ]]; then
                    local type_dir=""
                    case "$type_name" in
                        skills) type_dir="$skills" ;;
                        agents) type_dir="$agents" ;;
                        rules) type_dir="$rules" ;;
                        commands) type_dir="$commands" ;;
                        prompts) type_dir="$prompts" ;;
                    esac
                    if [[ "$type_dir" != "." ]]; then
                        local target="$HOME/$dir_name/$type_dir"
                        if [[ -L "$target" ]]; then
                            echo -e "  ${GREEN}✓${NC} $target"
                        elif [[ -e "$target" ]]; then
                            echo -e "  ${YELLOW}!${NC} $target (not a symlink)"
                        else
                            echo -e "  ${RED}✗${NC} $target (missing)"
                        fi
                    fi
                    break
                fi
            done
        done < "$KNOWN_TOOLS_FILE"
    done

    echo ""
    log_info "Shared: skills=$(count_files "$SKILLS_DIR"), agents=$(count_files "$AGENTS_DIR"), rules=$(count_files "$RULES_DIR"), commands=$(count_files "$COMMANDS_DIR"), prompts=$(count_files "$PROMPTS_DIR")"
}

# List supported tools
list_supported() {
    log_info "Supported AI tools:"
    echo ""
    printf "  ${BLUE}%-22s${NC} %-20s %-6s %-6s %-6s %-6s %-6s %s\n" "Directory" "Tool" "Skills" "Agents" "Rules" "Cmds" "Prompts" "Status"
    echo "  ----------------------------------------------------------------------------------------------------------------"

    for pattern in "${KNOWN_PATTERNS[@]}"; do
        IFS='|' read -r dir_name tool_name instr_file skills agents rules commands prompts <<< "$pattern"
        local full_path="$HOME/$dir_name"

        local s="." a="." r="." c="." p="."
        [[ "$skills" != "." ]] && s="✓"
        [[ "$agents" != "." ]] && a="✓"
        [[ "$rules" != "." ]] && r="✓"
        [[ "$commands" != "." ]] && c="✓"
        [[ "$prompts" != "." ]] && p="✓"

        local status=""
        if [[ -d "$full_path" ]]; then
            status="${GREEN}Installed${NC}"
        else
            status="${YELLOW}Not found${NC}"
        fi

        printf "  %-22s %-20s %-6s %-6s %-6s %-6s %-6s %b\n" "$dir_name" "$tool_name" "$s" "$a" "$r" "$c" "$p" "$status"
    done
    echo ""
}

# List available backups
list_backups() {
    log_info "Available backups:"
    echo ""

    if [[ ! -d "$BACKUP_DIR" ]] || [[ -z "$(ls -A "$BACKUP_DIR" 2>/dev/null)" ]]; then
        echo "  No backups found"
        echo ""
        return
    fi

    printf "  ${BLUE}%-25s${NC} %-12s %s\n" "Tool" "Type" "Backup File"
    echo "  ----------------------------------------------------------------"

    for backup in "$BACKUP_DIR"/*; do
        [[ ! -e "$backup" ]] && continue
        local filename=$(basename "$backup")
        local tool_name=""
        local type=""

        if [[ "$filename" =~ ^(.+)\.([^.]+)\.([0-9]+)$ ]]; then
            tool_name="${BASH_REMATCH[1]}"
            type="${BASH_REMATCH[2]}"
        else
            tool_name="$filename"
            type="unknown"
        fi

        printf "  %-25s %-12s %s\n" "$tool_name" "$type" "$filename"
    done
    echo ""
}

# Collect and merge instructions from all tools
collect_instructions() {
    local merged_content=""
    local found_count=0

    for pattern in "${KNOWN_PATTERNS[@]}"; do
        IFS='|' read -r dir_name tool_name instr_file skills agents rules commands prompts <<< "$pattern"

        if [[ "$instr_file" != "." ]] && [[ "$instr_file" != *.json ]] && [[ "$instr_file" != *.yml ]]; then
            local actual_path="$HOME/$dir_name/$instr_file"
            [[ -L "$actual_path" ]] && continue

            if [[ -f "$actual_path" ]]; then
                local content=$(cat "$actual_path" 2>/dev/null)
                if [[ -n "$content" ]]; then
                    if [[ $found_count -gt 0 ]]; then
                        merged_content+="\n\n---\n\n"
                    fi
                    merged_content+="# From $tool_name\n\n$content"
                    ((found_count++))
                fi
            fi
        fi
    done

    if [[ $found_count -gt 0 ]]; then
        echo -e "$merged_content" > "$INSTRUCTIONS_MD"
        log_ok "Merged instructions from $found_count tool(s)"
    else
        cat > "$INSTRUCTIONS_MD" << 'EOF'
# AI Assistant Instructions

<!-- Add your instructions here. They will sync to all AI tools. -->
EOF
        log_ok "Created: $INSTRUCTIONS_MD"
    fi
}

# Update: scan, merge and link tools
update_tools() {
    log_info "Scanning for AI tools..."
    echo ""

    mkdir -p "$SKILLS_DIR" "$AGENTS_DIR" "$RULES_DIR" "$COMMANDS_DIR" "$PROMPTS_DIR" "$BACKUP_DIR"

    if [[ ! -f "$INSTRUCTIONS_MD" ]]; then
        collect_instructions
    fi

    > "$KNOWN_TOOLS_FILE"

    local tool_count=0

    for pattern in "${KNOWN_PATTERNS[@]}"; do
        IFS='|' read -r dir_name tool_name instr_file skills agents rules commands prompts <<< "$pattern"
        local full_path="$HOME/$dir_name"

        if [[ -d "$full_path" ]]; then
            log_ok "Found: $tool_name"
            ((tool_count++))

            if [[ "$instr_file" != "." ]] && [[ "$instr_file" != *.json ]] && [[ "$instr_file" != *.yml ]]; then
                local actual_path="$HOME/$dir_name/$instr_file"
                backup_item "$actual_path" "$dir_name" "instructions"
            fi

            for type_name in skills agents rules commands prompts; do
                local type_dir=""
                case "$type_name" in
                    skills) type_dir="$skills" ;;
                    agents) type_dir="$agents" ;;
                    rules) type_dir="$rules" ;;
                    commands) type_dir="$commands" ;;
                    prompts) type_dir="$prompts" ;;
                esac
                if [[ "$type_dir" != "." ]]; then
                    local path="$HOME/$dir_name/$type_dir"
                    backup_item "$path" "$dir_name" "$type_name"
                    local target_dir=""
                    case "$type_name" in
                        skills) target_dir="$SKILLS_DIR" ;;
                        agents) target_dir="$AGENTS_DIR" ;;
                        rules) target_dir="$RULES_DIR" ;;
                        commands) target_dir="$COMMANDS_DIR" ;;
                        prompts) target_dir="$PROMPTS_DIR" ;;
                    esac
                    merge_items "$path" "$target_dir" "$type_name"
                fi
            done

            echo "$dir_name" >> "$KNOWN_TOOLS_FILE"
        fi
    done

    if [[ $tool_count -eq 0 ]]; then
        log_info "No AI tools found."
        return
    fi

    echo ""
    log_info "Creating symlinks..."

    while IFS= read -r dir_name; do
        [[ -z "$dir_name" ]] && continue

        for pattern in "${KNOWN_PATTERNS[@]}"; do
            IFS='|' read -r known_dir tool_name instr_file skills agents rules commands prompts <<< "$pattern"

            if [[ "$dir_name" == "$known_dir" ]]; then
                if [[ "$instr_file" != "." ]] && [[ "$instr_file" != *.json ]] && [[ "$instr_file" != *.yml ]]; then
                    local target="$HOME/$dir_name/$instr_file"
                    create_symlink "$INSTRUCTIONS_MD" "$target"
                    log_ok "$target -> instructions.md"
                fi

                for type_name in skills agents rules commands prompts; do
                    local type_dir=""
                    local source_dir=""
                    case "$type_name" in
                        skills) type_dir="$skills"; source_dir="$SKILLS_DIR" ;;
                        agents) type_dir="$agents"; source_dir="$AGENTS_DIR" ;;
                        rules) type_dir="$rules"; source_dir="$RULES_DIR" ;;
                        commands) type_dir="$commands"; source_dir="$COMMANDS_DIR" ;;
                        prompts) type_dir="$prompts"; source_dir="$PROMPTS_DIR" ;;
                    esac
                    if [[ "$type_dir" != "." ]]; then
                        local target="$HOME/$dir_name/$type_dir"
                        create_symlink "$source_dir" "$target"
                        log_ok "$target -> $type_name/"
                    fi
                done

                break
            fi
        done
    done < "$KNOWN_TOOLS_FILE"

    echo ""
    log_info "Done! Shared: skills=$(count_files "$SKILLS_DIR"), agents=$(count_files "$AGENTS_DIR"), rules=$(count_files "$RULES_DIR"), commands=$(count_files "$COMMANDS_DIR"), prompts=$(count_files "$PROMPTS_DIR")"
}

# Restore a single tool
restore_single_tool() {
    local tool_name="$1"
    local dir_name="$2"
    local instr_file="$3"
    local skills="$4"
    local agents="$5"
    local rules="$6"
    local commands="$7"
    local prompts="$8"

    log_ok "Restoring: $tool_name"
    local backup_name=$(echo "$dir_name" | tr '/' '_')

    if [[ "$instr_file" != "." ]]; then
        local target="$HOME/$dir_name/$instr_file"
        if [[ -L "$target" ]]; then
            rm "$target"
            local backup_file=$(ls -t "$BACKUP_DIR"/${backup_name}.instructions.* 2>/dev/null | head -1)
            [[ -f "$backup_file" ]] && cp "$backup_file" "$target"
        fi
    fi

    for type_name in skills agents rules commands prompts; do
        local type_dir=""
        case "$type_name" in
            skills) type_dir="$skills" ;;
            agents) type_dir="$agents" ;;
            rules) type_dir="$rules" ;;
            commands) type_dir="$commands" ;;
            prompts) type_dir="$prompts" ;;
        esac
        if [[ "$type_dir" != "." ]]; then
            local target="$HOME/$dir_name/$type_dir"
            if [[ -L "$target" ]]; then
                rm "$target"
                local backup_file=$(ls -td "$BACKUP_DIR"/${backup_name}.${type_name}.* 2>/dev/null | head -1)
                if [[ -d "$backup_file" ]]; then
                    cp -r "$backup_file" "$target"
                else
                    mkdir -p "$target"
                fi
            fi
        fi
    done
}

# Restore all tools
restore_all_tools() {
    log_info "Restoring all tools..."
    echo ""

    if [[ ! -f "$KNOWN_TOOLS_FILE" ]]; then
        log_info "No tools to restore"
        return
    fi

    local restored_count=0

    while IFS= read -r dir_name; do
        [[ -z "$dir_name" ]] && continue

        for pattern in "${KNOWN_PATTERNS[@]}"; do
            IFS='|' read -r known_dir tool_name instr_file skills agents rules commands prompts <<< "$pattern"

            if [[ "$dir_name" == "$known_dir" ]]; then
                restore_single_tool "$tool_name" "$dir_name" "$instr_file" "$skills" "$agents" "$rules" "$commands" "$prompts"
                ((restored_count++))
                break
            fi
        done
    done < "$KNOWN_TOOLS_FILE"

    rm -f "$KNOWN_TOOLS_FILE"

    echo ""
    log_info "Restored $restored_count tool(s). Run 'ai-config' to re-link."
}

# Restore a specific tool
restore_tool() {
    local tool_query="$1"

    if [[ -z "$tool_query" ]]; then
        log_error "Usage: ai-config restore <tool> or ai-config restore all"
        echo ""
        list_backups
        return 1
    fi

    if [[ "$tool_query" == "all" ]]; then
        restore_all_tools
        return
    fi

    local found=false

    for pattern in "${KNOWN_PATTERNS[@]}"; do
        IFS='|' read -r dir_name tool_name instr_file skills agents rules commands prompts <<< "$pattern"
        local tool_lower=$(echo "$tool_name" | tr '[:upper:]' '[:lower:]')
        local query_lower=$(echo "$tool_query" | tr '[:upper:]' '[:lower:]')

        if [[ "$tool_lower" == *"$query_lower"* ]] || [[ "$dir_name" == *"$query_lower"* ]]; then
            log_info "Restoring $tool_name..."
            restore_single_tool "$tool_name" "$dir_name" "$instr_file" "$skills" "$agents" "$rules" "$commands" "$prompts"

            if [[ -f "$KNOWN_TOOLS_FILE" ]]; then
                grep -v "^$dir_name$" "$KNOWN_TOOLS_FILE" > "$KNOWN_TOOLS_FILE.tmp" 2>/dev/null || true
                mv "$KNOWN_TOOLS_FILE.tmp" "$KNOWN_TOOLS_FILE"
            fi

            log_info "$tool_name restored"
            found=true
            break
        fi
    done

    if [[ "$found" == false ]]; then
        log_error "Tool not found: $tool_query"
        echo ""
        echo "Use 'ai-config list' to see supported tools"
        return 1
    fi
}

# Check if input is a GitHub reference
is_github_ref() {
    local input="$1"
    # Match: user/repo, https://github.com/user/repo, github.com/user/repo
    if [[ "$input" =~ ^https?://github\.com/ ]] || \
       [[ "$input" =~ ^github\.com/ ]] || \
       [[ "$input" =~ ^[a-zA-Z0-9_-]+/[a-zA-Z0-9_.-]+(/.*)?$ ]]; then
        return 0
    fi
    return 1
}

# Parse GitHub reference to get owner, repo, and optional path
parse_github_ref() {
    local input="$1"

    # Remove https://github.com/ or github.com/ prefix
    input="${input#https://github.com/}"
    input="${input#http://github.com/}"
    input="${input#github.com/}"

    # Remove /blob/main/ or /blob/master/ or /tree/main/ etc for file/dir paths
    input=$(echo "$input" | sed -E 's|/blob/[^/]+/|/|; s|/tree/[^/]+/|/|')

    echo "$input"
}

# Download from GitHub
download_from_github() {
    local type="$1"
    local ref="$2"
    local target_dir="$3"

    local parsed=$(parse_github_ref "$ref")
    local owner=$(echo "$parsed" | cut -d'/' -f1)
    local repo=$(echo "$parsed" | cut -d'/' -f2)
    local path=$(echo "$parsed" | cut -d'/' -f3-)

    if [[ -z "$owner" ]] || [[ -z "$repo" ]]; then
        log_error "Invalid GitHub reference: $ref"
        return 1
    fi

    # If path points to a specific file
    if [[ -n "$path" ]] && [[ "$path" == *.md ]]; then
        local filename=$(basename "$path")
        local raw_url="https://raw.githubusercontent.com/$owner/$repo/main/$path"

        log_info "Downloading: $raw_url"

        if curl -fsSL "$raw_url" -o "$target_dir/$filename" 2>/dev/null; then
            log_ok "Added $type: $target_dir/$filename"
        else
            # Try master branch
            raw_url="https://raw.githubusercontent.com/$owner/$repo/master/$path"
            if curl -fsSL "$raw_url" -o "$target_dir/$filename" 2>/dev/null; then
                log_ok "Added $type: $target_dir/$filename"
            else
                log_error "Failed to download: $ref"
                return 1
            fi
        fi
    else
        # Clone entire repo or subdirectory
        local tmp_dir=$(mktemp -d)
        local clone_url="https://github.com/$owner/$repo.git"

        log_info "Cloning: $clone_url"

        if git clone --depth 1 --single-branch "$clone_url" "$tmp_dir/$repo"; then
            local source_dir="$tmp_dir/$repo"
            [[ -n "$path" ]] && source_dir="$tmp_dir/$repo/$path"

            if [[ -d "$source_dir" ]]; then
                # Auto-detect type subdirectory (e.g., skills/, agents/, rules/)
                if [[ -z "$path" ]]; then
                    local type_dirs=""
                    case "$type" in
                        skill)   type_dirs="skills skill" ;;
                        agent)   type_dirs="agents agent" ;;
                        rule)    type_dirs="rules rule" ;;
                        command) type_dirs="commands command" ;;
                        prompt)  type_dirs="prompts prompt" ;;
                    esac

                    # Prefer type subdirectory, fallback to root
                    for dir in $type_dirs; do
                        if [[ -d "$source_dir/$dir" ]]; then
                            source_dir="$source_dir/$dir"
                            log_info "Found $dir/ directory"
                            break
                        fi
                    done
                fi

                local count=0

                # Special case: many skill repos are structured as:
                # skills/<skill-name>/SKILL.md
                if [[ "$type" == "skill" ]] && [[ "$(basename "$source_dir")" == "skills" ]]; then
                    for d in "$source_dir"/*; do
                        [[ ! -d "$d" ]] && continue
                        local skill_md="$d/SKILL.md"
                        [[ ! -f "$skill_md" ]] && continue

                        local skill_name=$(basename "$d")

                        # Copy the entire skill directory so assets/examples are preserved
                        local target_skill_dir="$target_dir/$skill_name"
                        mkdir -p "$target_skill_dir"
                        cp -R "$d/" "$target_skill_dir/"

                        ((count++))
                    done
                fi

                # Fallback: copy top-level .md files from the selected source directory
                if [[ $count -eq 0 ]]; then
                    for file in "$source_dir"/*.md; do
                        [[ ! -f "$file" ]] && continue
                        local filename=$(basename "$file")
                        cp "$file" "$target_dir/$filename"
                        ((count++))
                    done
                fi

                if [[ $count -gt 0 ]]; then
                    log_ok "Added $count ${type}(s) from $owner/$repo"
                else
                    # Show actual searched path
                    local searched_path="${source_dir#$tmp_dir/$repo}"
                    searched_path="${searched_path#/}"
                    log_warn "No skills found in $owner/$repo${searched_path:+/$searched_path}"
                fi
            else
                log_error "Path not found: $path"
                rm -rf "$tmp_dir"
                return 1
            fi

            rm -rf "$tmp_dir"
        else
            rm -rf "$tmp_dir"
            log_error "Failed to clone: $clone_url"
            return 1
        fi
    fi
}

# Add item to a type directory
add_item() {
    local type="$1"
    local input="$2"

    if [[ -z "$input" ]]; then
        log_error "Usage: ai-config $type <file|github-repo>"
        echo ""
        echo "Examples:"
        echo "  ai-config $type react.md"
        echo "  ai-config $type /path/to/file.md"
        echo "  ai-config $type user/repo"
        echo "  ai-config $type https://github.com/user/repo"
        echo "  ai-config $type user/repo/path/to/file.md"
        return 1
    fi

    local target_dir=""
    case "$type" in
        skill)   target_dir="$SKILLS_DIR" ;;
        agent)   target_dir="$AGENTS_DIR" ;;
        rule)    target_dir="$RULES_DIR" ;;
        command) target_dir="$COMMANDS_DIR" ;;
        prompt)  target_dir="$PROMPTS_DIR" ;;
    esac

    mkdir -p "$target_dir"

    # Check if it's a GitHub reference
    if is_github_ref "$input"; then
        download_from_github "$type" "$input" "$target_dir"
    elif [[ -f "$input" ]]; then
        # Local file
        local basename=$(basename "$input")
        cp "$input" "$target_dir/$basename"
        log_ok "Added $type: $target_dir/$basename"
    else
        # Create new file
        local target_file="$target_dir/$input"
        if [[ ! "$input" == *.md ]]; then
            target_file="$target_dir/${input}.md"
        fi
        touch "$target_file"
        log_ok "Created $type: $target_file"
        echo "Edit: $target_file"
    fi
}

# Uninstall
uninstall() {
    log_warn "This will:"
    echo "  1. Restore all tools to original configuration"
    echo "  2. Remove ~/.ai-config directory"
    echo "  3. Remove ai-config from PATH"
    echo ""
    read -p "Are you sure? (y/N) " -r
    echo ""

    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        log_info "Cancelled"
        return
    fi

    if [[ -f "$KNOWN_TOOLS_FILE" ]]; then
        restore_all_tools
    fi

    [[ -L /usr/local/bin/ai-config ]] && rm -f /usr/local/bin/ai-config
    [[ -L "$HOME/.local/bin/ai-config" ]] && rm -f "$HOME/.local/bin/ai-config"

    rm -rf "$CONFIG_DIR"

    log_ok "AI-Config uninstalled"
}

# Show version
show_version() {
    echo "ai-config version $VERSION"
}

# Upgrade
upgrade() {
    log_info "Checking for updates..."

    local remote_version
    remote_version=$(curl -fsSL "https://raw.githubusercontent.com/nanxiaobei/ai-config/main/package.json" 2>/dev/null | grep '"version"' | head -1 | sed 's/.*"version": *"\([^"]*\)".*/\1/')

    if [[ -z "$remote_version" ]]; then
        log_warn "Could not check for updates"
        return 1
    fi

    if [[ "$remote_version" == "$VERSION" ]]; then
        log_ok "Already at latest version ($VERSION)"
        return 0
    fi

    log_info "Upgrading: $VERSION -> $remote_version"

    local tmp_file=$(mktemp)
    if curl -fsSL "https://raw.githubusercontent.com/nanxiaobei/ai-config/main/ai-config" -o "$tmp_file" 2>/dev/null; then
        chmod +x "$tmp_file"
        mv "$tmp_file" "$CONFIG_DIR/ai-config"
        log_ok "Upgraded to v$remote_version"
    else
        rm -f "$tmp_file"
        log_error "Failed to download update"
        return 1
    fi
}

# Show help
show_help() {
    cat << EOF
AI-Config: Unified AI Tools Configuration Manager v$VERSION

Usage: ai-config [command]

Commands:
  (default)            Scan, merge and update symlinks
  status               Show symlink status
  list                 List all supported AI tools
  backups              List available backups
  restore <tool>       Restore a tool's original config
  restore all          Restore all tools
  skill <source>       Add a skill (file, GitHub repo, or new)
  agent <source>       Add an agent
  rule <source>        Add a rule
  command <source>     Add a command
  prompt <source>      Add a prompt
  upgrade              Upgrade ai-config to latest version
  uninstall            Completely remove ai-config
  version              Show version
  help                 Show this help

Shared directories:
  ~/.ai-config/instructions.md   Instructions for all tools
  ~/.ai-config/skills/           Reusable skills
  ~/.ai-config/agents/           Custom agents
  ~/.ai-config/rules/            Code rules
  ~/.ai-config/commands/         Slash commands
  ~/.ai-config/prompts/          Prompt templates

Examples:
  ai-config                      # Scan, merge and update symlinks
  ai-config skill react.md       # Add a local skill file
  ai-config skill user/repo      # Add skills from GitHub repo (auto-detects skills/ dir)
  ai-config agent coder.md       # Add an agent
  ai-config restore claude       # Restore Claude's config

Note: When adding from GitHub, it auto-detects type subdirectories
      (e.g., skills/, agents/, rules/) if they exist.

EOF
}

# Main
main() {
    local cmd="${1:-update}"

    if [[ "$1" == "-v" ]] || [[ "$1" == "--version" ]] || [[ "$1" == "version" ]]; then
        show_version
        exit 0
    fi

    if [[ ! -f "$KNOWN_TOOLS_FILE" ]]; then
        case "$cmd" in
            help|--help|-h) show_help; exit 0 ;;
            list) list_supported; exit 0 ;;
            version|-v|--version) show_version; exit 0 ;;
            skill|agent|rule|command|prompt|restore|status|backups)
                log_info "No tools configured yet. Running initial scan..."
                update_tools
                [[ "$cmd" == "skill" || "$cmd" == "agent" || "$cmd" == "rule" || "$cmd" == "command" || "$cmd" == "prompt" ]] || exit 0
                ;;
            *) cmd="update" ;;
        esac
    fi

    case "$cmd" in
        update)       update_tools ;;
        status)       show_status ;;
        list)         list_supported ;;
        backups)      list_backups ;;
        restore)      restore_tool "$2" ;;
        skill)        add_item "skill" "$2" ;;
        agent)        add_item "agent" "$2" ;;
        rule)         add_item "rule" "$2" ;;
        command)      add_item "command" "$2" ;;
        prompt)       add_item "prompt" "$2" ;;
        upgrade)      upgrade ;;
        uninstall)    uninstall ;;
        version|-v|--version) show_version ;;
        help|--help|-h) show_help ;;
        *)            log_error "Unknown command: $cmd"; show_help; exit 1 ;;
    esac
}

main "$@"
