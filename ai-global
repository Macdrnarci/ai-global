#!/bin/bash

# AI Global: Unified AI Tools Configuration Manager
# https://github.com/nanxiaobei/ai-global

# Version
VERSION="2.1.0"

# Known AI tool patterns
# Format: nodes|key|name|agents_md|rules|commands|skills|subagents|color
declare -a KNOWN_PATTERNS=(
  ".amp|amp|Amp|AGENTS.md|rules|commands|skills|.|\\033[38;5;226m"
  ".augment|augment|Augment|AGENTS.md|rules|commands|.|agents|\\033[38;5;46m"
  ".blackbox|blackbox|Blackbox AI|.|.|.|skills|.|\\033[38;5;51m"
  ".claude|claude|Claude Code|CLAUDE.md|.|commands|skills|agents|\\033[38;5;180m"
  ".cline|cline|Cline|AGENTS.md|rules|.|skills|.|\\033[38;5;201m"
  ".clawdbot|clawdbot|Clawdbot Code|AGENTS.md|.|.|skills|subagents|\\033[38;5;208m"
  ".codex|codex|OpenAI Codex|AGENTS.md|rules|.|skills|agents|\\033[38;5;9m"
  ".commandcode|commandcode|Command Code|AGENTS.md|.|.|skills|.|\\033[38;5;11m"
  ".continue|continue|Continue|AGENTS.md|rules|.|.|.|\\033[38;5;10m"
  ".copilot|copilot|GitHub Copilot|AGENTS.md|.|.|skills|agents|\\033[38;5;14m"
  ".cursor|cursor|Cursor|AGENTS.md|rules|commands|skills|agents|\\033[38;5;12m"
  ".factory|droid|Factory Droid|AGENTS.md|rules|commands|skills|droids|\\033[38;5;13m"
  ".gemini|antigravity|Antigravity|GEMINI.md|.|.|antigravity/skills|.|\\033[38;5;214m"
  ".gemini|gemini|Gemini CLI|GEMINI.md|.|.|skills|.|\\033[38;5;220m"
  ".goose|goose|Goose AI|AGENTS.md|.|.|skills|.|\\033[38;5;82m"
  ".kiro|kiro|Kiro CLI|AGENTS.md|steering|.|skills|agents|\\033[38;5;117m"
  ".kilocode|kilocode|Kilo Code|AGENTS.md|rules|commands|skills|.|\\033[38;5;165m"
  ".neovate|neovate|Neovate|AGENTS.md|.|commands|skills|agents|\\033[38;5;118m"
  ".opencode, .config/opencode|opencode|OpenCode|AGENTS.md|.|commands|skills|agents|\\033[38;5;225m"
  ".openhands|openhands|OpenHands|AGENTS.md|.|.|skills|.|\\033[38;5;39m"
  ".qodo|qodo|Qodo|AGENTS.md|.|.|.|agents|\\033[38;5;129m"
  ".qoder|qoder|Qoder|AGENTS.md|rules|commands|skills|agents|\\033[38;5;203m"
  ".roo|roo|Roo Code|AGENTS.md|rules|commands|skills|.|\\033[38;5;77m"
  ".trae|trae|TRAE|AGENTS.md|rules|.|skills|.|\\033[38;5;215m"
  ".windsurf, .codeium/windsurf|windsurf|Windsurf|AGENTS.md|rules|.|skills|.|\\033[38;5;159m"
  ".zencoder|zencoder|Zencoder|AGENTS.md|rules|.|skills|.|\\033[38;5;147m"
)

# Colors
BLUE='\033[0;34m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
RED='\033[0;31m'
GRAY='\033[0;90m'
NC='\033[0m'

log_info() { echo -e "${BLUE}[INFO]${NC} $1"; }
log_ok() { echo -e "${GREEN}[OK]${NC} $1"; }
log_warn() { echo -e "${YELLOW}[WARN]${NC} $1"; }
log_error() { echo -e "${RED}[ERROR]${NC} $1"; }

# Beautify a directory path
beautify_dir() {
  local path="$1"
  if [[ "$path" == "$HOME"* ]]; then
    echo "~${path#$HOME}"
  else
    echo "$path"
  fi
}

# Log context mode info
log_context_info() {
  local base_dir="$1"

  local mode="system"
  [[ "$base_dir" != "$HOME" ]] && mode="project"

  log_info "Directory: $(beautify_dir "$base_dir") ($mode mode)"
  echo ""
}

# Update: scan, merge, update symlinks
update_links() {
  local base_dir=$(pwd)
  log_context_info "$base_dir"

  log_info "Scanning AI tools..."

  local global_md_dir="$base_dir/.ai-global/global.md"
  local agents_md_dir="$base_dir/.ai-global/AGENTS.md"
  if [[ -f "$global_md_dir" ]] && [[ ! -f "$agents_md_dir" ]]; then
    mv "$global_md_dir" "$agents_md_dir"
    log_ok "Renamed legacy global.md to AGENTS.md"
  fi

  local rules_dir="$base_dir/.ai-global/rules"
  local commands_dir="$base_dir/.ai-global/commands"
  local skills_dir="$base_dir/.ai-global/skills"
  local subagents_dir="$base_dir/.ai-global/agents"
  local backups_dir="$base_dir/.ai-global/backups"

  local total_tools=0

  # Create .ai-global directory if it doesn't exist
  if [[ ! -d "$base_dir/.ai-global" ]]; then
    mkdir -p "$base_dir/.ai-global"
  fi

  # Record project if in project mode
  if [[ "$base_dir" != "$HOME" ]]; then
    local projects_file="$HOME/.ai-global/projects"
    mkdir -p "$(dirname "$projects_file")"
    if [[ ! -f "$projects_file" ]]; then
      echo "$base_dir" > "$projects_file"
    elif ! grep -Fxq "$base_dir" "$projects_file" 2> /dev/null; then
      echo "$base_dir" >> "$projects_file"
    fi
  fi

  # Handle AGENTS.md
  local is_new_agents_md=false
  if [[ ! -L "$agents_md_dir" ]] && [[ ! -f "$agents_md_dir" ]]; then
    touch "$agents_md_dir"
    is_new_agents_md=true
  fi

  # Create directories
  mkdir -p "$rules_dir" "$commands_dir" "$skills_dir" "$subagents_dir" "$backups_dir"

  for pattern in "${KNOWN_PATTERNS[@]}"; do
    IFS='|' read -r nodes key name agents_md rules commands skills subagents color <<< "$pattern"
    IFS=', ' read -ra node_array <<< "$nodes"

    for tool_node in "${node_array[@]}"; do
      local tool_dir="$base_dir/$tool_node"

      if [[ -d "$tool_dir" ]]; then
        total_tools=$((total_tools + 1))

        echo ""
        echo -e "${GREEN}[OK]${NC} ${color}Found: $name${NC}"

        local types=("file:$agents_md:$agents_md_dir" "dir:$rules:$rules_dir" "dir:$commands:$commands_dir" "dir:$skills:$skills_dir" "dir:$subagents:$subagents_dir")

        for type_info in "${types[@]}"; do
          IFS=':' read -r type_key type_node target_dir <<< "$type_info"

          if [[ "$type_node" != "." ]]; then
            local type_dir="$tool_dir/$type_node"

            # If not symlink, create symlink
            if [[ ! -L "$type_dir" ]]; then
              # If dir exists, backup & copy & remove
              if [[ -e "$type_dir" ]]; then
                # Backup
                local backup_file="$backups_dir/${tool_node//\//_}.${type_node//\//_}.backup"
                cp -r "$type_dir" "$backup_file" 2> /dev/null

                if [[ "$type_key" == "file" ]]; then
                  # Copy
                  if [[ "$is_new_agents_md" == true ]]; then
                    echo "<!-- $name -->" >> "$target_dir"
                    cat "$type_dir" >> "$target_dir"
                    echo "" >> "$target_dir"
                    echo "" >> "$target_dir"
                  fi
                else
                  # Copy all files (overwrite if exists)
                  find "$type_dir" -type f -print0 2> /dev/null | while IFS= read -r -d '' file_dir; do
                    local target_file="$target_dir/${file_dir#$type_dir/}"
                    cp "$file_dir" "$target_file" 2> /dev/null || true
                  done
                fi

                # Remove
                rm -rf "$type_dir"
              fi

              # Create symlink whether exists or not
              ln -s "$target_dir" "$type_dir"
            fi

            # Print symlink
            local src_dir=$(beautify_dir "$type_dir")
            local tgt_dir=$(beautify_dir "$target_dir")
            local src_spaces=$((40 - ${#src_dir}))
            src_spaces=$((src_spaces > 0 ? src_spaces : 1))
            local src_spacing="                                        "
            src_spacing="${src_spacing:0:$src_spaces}"
            echo -e "${color}${src_dir}${src_spacing} ${GRAY}→ ${tgt_dir}${NC}"
          fi
        done
      fi
    done
  done

  echo ""

  # Check if any tools were found
  if [[ $total_tools -eq 0 ]]; then
    log_info "No AI tool configurations found"
    # Remove empty .ai-global directory
    rm -rf "$base_dir/.ai-global" 2> /dev/null
    echo ""
    return
  fi

  if [[ "$is_new_agents_md" == true ]]; then
    if [[ -f "$agents_md_dir" ]] && ! grep -q '[^[:space:]]' "$agents_md_dir" 2> /dev/null; then
      cat > "$agents_md_dir" << 'EOF'
# AI Coding Assistant

<!-- Add your prompts here. They will sync to all AI tools. -->
EOF
    fi
    log_info "Merged AGENTS.md: $(beautify_dir "$agents_md_dir")"
  else
    log_info "Skipped merge: $(beautify_dir "$agents_md_dir") (already exists)"
  fi

  log_ok "Done!"
  echo ""
}

# Show symlink status
show_status() {
  local base_dir=$(pwd)
  log_context_info "$base_dir"

  total_links=0

  # Check and add symlink to output
  add_status_output() {
    local color="$1"
    local tool_dir="$2"
    local type_node="$3"
    local out_var="$4"

    if [[ "$type_node" != "." ]]; then
      local type_dir="$tool_dir/$type_node"
      if [[ -L "$type_dir" ]]; then
        local target_dir=$(readlink "$type_dir" 2> /dev/null || true)
        if [[ "$target_dir" == *".ai-global"* ]]; then
          local beautified=$(beautify_dir "$type_dir")
          eval "$out_var+=\"  ${color}${beautified}${NC}\n\""
          total_links=$((total_links + 1))
        fi
      fi
    fi
  }

  local agents_md_output=""
  local rules_output=""
  local commands_output=""
  local skills_output=""
  local subagents_output=""

  for pattern in "${KNOWN_PATTERNS[@]}"; do
    IFS='|' read -r nodes key name agents_md rules commands skills subagents color <<< "$pattern"
    IFS=', ' read -ra node_array <<< "$nodes"

    for tool_node in "${node_array[@]}"; do
      local tool_dir="$base_dir/$tool_node"

      if [[ -d "$tool_dir" ]]; then
        local types=("$agents_md:agents_md_output" "$rules:rules_output" "$commands:commands_output" "$skills:skills_output" "$subagents:subagents_output")

        for type_info in "${types[@]}"; do
          IFS=':' read -r type_node output_var <<< "$type_info"
          add_status_output "$color" "$tool_dir" "$type_node" "$output_var"
        done
      fi
    done
  done

  if [[ $total_links -eq 0 ]]; then
    echo "  No symlinks found"
    echo ""
    return
  fi

  local types=("AGENTS.md:$agents_md_output" "rules:$rules_output" "commands:$commands_output" "skills:$skills_output" "agents:$subagents_output")

  for type_info in "${types[@]}"; do
    IFS=':' read -r title content <<< "$type_info"
    if [[ -n "$content" ]]; then
      echo -e "${BLUE}[$title]${NC}"
      echo -e -n "$content\n"
    fi
  done
}

# List supported tools
list_tools() {
  local base_dir=$(pwd)
  log_context_info "$base_dir"

  echo -e "  ${BLUE}Tool             Key          Directory                    AGENTS.md Rules Commands Skills Agents Status${NC}"
  echo -e "  ${BLUE}-----------------------------------------------------------------------------------------------------------${NC}"

  for pattern in "${KNOWN_PATTERNS[@]}"; do
    IFS='|' read -r nodes key name agents_md rules commands skills subagents color <<< "$pattern"
    IFS=', ' read -ra node_array <<< "$nodes"

    local row_color="${GRAY}"
    local status="Not found"

    for tool_node in "${node_array[@]}"; do
      local tool_dir="$base_dir/$tool_node"

      if [[ -d "$tool_dir" ]]; then
        row_color="$color"
        status="Installed"
        break
      fi
    done

    local name_spaces=$((17 - ${#name}))
    name_spaces=$((name_spaces > 0 ? name_spaces : 1))
    local name_pad="                    "
    name_pad="${name_pad:0:$name_spaces}"

    local key_pad=$((13 - ${#key}))
    key_pad=$((key_pad > 0 ? key_pad : 1))
    local key_spacing="            "
    key_spacing="${key_spacing:0:$key_pad}"

    local nodes_spaces=$((31 - ${#nodes}))
    nodes_spaces=$((nodes_spaces > 0 ? nodes_spaces : 1))
    local nodes_pad="                               "
    nodes_pad="${nodes_pad:0:$nodes_spaces}"

    echo -e "  ${row_color}${name}${name_pad}${key}${key_spacing}${nodes}${nodes_pad} $([[ "$agents_md" == "." ]] && echo "." || echo "○")        $([[ "$rules" == "." ]] && echo "." || echo "○")      $([[ "$commands" == "." ]] && echo "." || echo "○")       $([[ "$skills" == "." ]] && echo "." || echo "○")      $([[ "$subagents" == "." ]] && echo "." || echo "○")    ${status}${NC}"
  done
  echo ""
}

# List available backups
list_backups() {
  local base_dir="$(pwd)"
  log_context_info "$base_dir"

  local backups_dir="$base_dir/.ai-global/backups"
  local backups_list=$(find "$backups_dir" -maxdepth 1 -name "*.backup" 2> /dev/null | sort)

  if [[ -z "$backups_list" ]]; then
    echo "  No backups found"
    echo ""
    return
  fi

  echo -e "  ${BLUE}Backup File${NC}"
  echo "  ----------------------------------------------------------------------"

  while IFS= read -r backup_dir; do
    [[ -z "$backup_dir" ]] && continue
    local display_dir=$(beautify_dir "$backup_dir")
    echo -e "  ${display_dir}"
  done <<< "$backups_list"
  echo ""
}

# Unlink a single tool
unlink_one_tool() {
  local base_dir="$1"
  local tool_node="$2"
  local agents_md="$3"
  local rules="$4"
  local commands="$5"
  local skills="$6"
  local subagents="$7"
  local color="$8"

  local unlinked_count=0

  for type_node in "$agents_md" "$rules" "$commands" "$skills" "$subagents"; do
    if [[ "$type_node" != "." ]]; then
      local type_dir="$base_dir/$tool_node/$type_node"
      if [[ -L "$type_dir" ]]; then
        rm "$type_dir"
        log_ok "Unlinked: ${color}$(beautify_dir "$type_dir")${NC}"
        ((unlinked_count++))

        # Restore from backup
        local backup_file="$base_dir/.ai-global/backups/${tool_node//\//_}.${type_node//\//_}.backup"
        if [[ -e "$backup_file" ]]; then
          cp -r "$backup_file" "$type_dir" 2> /dev/null
        fi
      fi
    fi
  done

  # Delete tool backups
  local backups_dir="$base_dir/.ai-global/backups"
  [[ -d "$backups_dir" ]] && for backup_dir in "$backups_dir"/${tool_node//\//_}.*.backup; do
    [[ -e "$backup_dir" ]] && rm -rf "$backup_dir"
  done

  return $unlinked_count
}

# Unlink all tools
unlink_all_tools() {
  local base_dir="$1"
  log_context_info "$base_dir"

  local total_unlinked=0

  for pattern in "${KNOWN_PATTERNS[@]}"; do
    IFS='|' read -r nodes key name agents_md rules commands skills subagents color <<< "$pattern"
    IFS=', ' read -ra node_array <<< "$nodes"

    for tool_node in "${node_array[@]}"; do
      local tool_dir="$base_dir/$tool_node"

      if [[ -d "$tool_dir" ]]; then
        unlink_one_tool "$base_dir" "$tool_node" "$agents_md" "$rules" "$commands" "$skills" "$subagents" "$color"
        total_unlinked=$((total_unlinked + $?))
      fi
    done
  done

  if [[ $total_unlinked -gt 0 ]]; then
    log_ok "Unlinked all $total_unlinked symlinks"
  else
    echo "  No symlinks found"
  fi
}

# Unlink command
unlink_tool() {
  local query_key="$1"

  if [[ -z "$query_key" ]]; then
    log_error "Usage: ai-global unlink <key> or ai-global unlink all"
    echo ""
    return 1
  fi

  local base_dir=$(pwd)

  if [[ "$query_key" == "all" ]]; then
    unlink_all_tools "$base_dir"
    echo ""
    return 0
  fi

  # Find pattern by searching KNOWN_PATTERNS
  local match=""
  for pattern in "${KNOWN_PATTERNS[@]}"; do
    IFS='|' read -r nodes key name agents_md rules commands skills subagents color <<< "$pattern"
    if [[ "$key" == "$query_key" ]]; then
      match="$pattern"
      break
    fi
  done

  if [[ -z "$match" ]]; then
    log_error "Unknown tool: $query_key"
    echo "Please use the correct <key>"
    echo ""
    list_tools
    return 1
  fi

  log_context_info "$base_dir"

  local has_found=false

  # Parse pattern and unlink tool
  IFS='|' read -r nodes key name agents_md rules commands skills subagents color <<< "$match"
  IFS=', ' read -ra node_array <<< "$nodes"

  for tool_node in "${node_array[@]}"; do
    local tool_dir="$base_dir/$tool_node"

    if [[ -d "$tool_dir" ]]; then
      has_found=true
      unlink_one_tool "$base_dir" "$tool_node" "$agents_md" "$rules" "$commands" "$skills" "$subagents" "$color"
      local unlinked_count=$?
      if [[ $unlinked_count -gt 0 ]]; then
        log_ok "Unlinked $unlinked_count symlinks from ${color}$(beautify_dir "$tool_dir")${NC}"
      else
        log_info "No symlinks found for ${color}$(beautify_dir "$tool_dir")${NC}"
      fi
      echo ""
    fi
  done

  if [[ "$has_found" != true ]]; then
    log_warn "Tool '$query_key' not found"
    echo ""
  fi
}

# Parse GitHub reference to get owner, repo, and optional path
parse_github_ref() {
  local input="$1"

  # Remove https://github.com/ or github.com/ prefix
  input="${input#https://github.com/}"
  input="${input#http://github.com/}"
  input="${input#github.com/}"

  # Remove /blob/main/ or /blob/master/ or /tree/main/ etc
  input=$(echo "$input" | sed -E 's|/blob/[^/]+/|/|; s|/tree/[^/]+/|/|')

  echo "$input"
}

# Extract name from frontmatter (name: "...")
extract_meta_name() {
  local file="$1"
  local default_name="$2"
  if [[ ! -f "$file" ]]; then
    echo "$default_name"
    return
  fi
  # Match name: "value" or name: value
  local extracted=$(grep -m 1 "^name:" "$file" | sed -E 's/^name:[[:space:]]*["'\'']?([^"'\'']+)["'\'']?/\1/' | xargs 2> /dev/null || true)
  if [[ -n "$extracted" ]]; then
    echo "$extracted"
  else
    echo "$default_name"
  fi
}

# Download from GitHub
download_from_github() {
  local type="$1"
  local ref="$2"
  local target_dir="$3"

  local parsed=$(parse_github_ref "$ref")
  local owner=$(echo "$parsed" | cut -d'/' -f1)
  local repo=$(echo "$parsed" | cut -d'/' -f2)
  local path=$(echo "$parsed" | cut -d'/' -f3-)

  if [[ -z "$owner" ]] || [[ -z "$repo" ]]; then
    log_error "Invalid GitHub reference: $ref"
    return 1
  fi

  # If path points to a specific file
  if [[ -n "$path" ]]; then
    local filename=$(basename "$path")
    local raw_url="https://raw.githubusercontent.com/$owner/$repo/main/$path"

    log_info "Downloading: $raw_url"

    if curl -fsSL "$raw_url" -o "$target_dir/$filename" 2> /dev/null; then
      log_ok "Added skill to $(beautify_dir "$target_dir/$filename")"
    else
      # Try master branch
      raw_url="https://raw.githubusercontent.com/$owner/$repo/master/$path"
      if curl -fsSL "$raw_url" -o "$target_dir/$filename" 2> /dev/null; then
        log_ok "Added skill to $(beautify_dir "$target_dir/$filename")"
      else
        log_error "Failed to download: $ref"
        return 1
      fi
    fi
  else
    # Clone entire repo or subdirectory
    local tmp_tool_node=$(mktemp -d)
    local clone_url="https://github.com/$owner/$repo.git"

    log_info "Cloning: $clone_url"

    if git clone --depth 1 --single-branch "$clone_url" "$tmp_tool_node/$repo"; then
      local source_node="$tmp_tool_node/$repo"
      [[ -n "$path" ]] && source_node="$tmp_tool_node/$repo/$path"

      if [[ -d "$source_node" ]]; then
        local count=0
        local meta_file="SKILL.md"

        # 1. Check if root contains metadata file
        if [[ -f "$source_node/$meta_file" ]]; then
          local name=$(extract_meta_name "$source_node/$meta_file" "$(basename "$source_node")")
          local file_dir="$target_dir/$name"
          mkdir -p "$file_dir"
          cp -R "$source_node"/* "$file_dir/"
          count=1
        fi

        # 2. Check skills/ subdirectories
        if [[ $count -eq 0 ]] && [[ -z "$path" ]]; then
          for dir in skills skill; do
            if [[ -d "$source_node/$dir" ]]; then
              # Search subdirectories containing SKILL.md
              for d in "$source_node/$dir"/*; do
                [[ ! -d "$d" ]] && continue
                if [[ -f "$d/$meta_file" ]]; then
                  local name=$(extract_meta_name "$d/$meta_file" "$(basename "$d")")
                  mkdir -p "$target_dir/$name"
                  cp -R "$d"/* "$target_dir/$name/"
                  ((count++))
                fi
              done
            fi

            # If we found items, we are done with this dir
            if [[ $count -gt 0 ]]; then
              source_node="$source_node/$dir"
              break
            fi
          done
        fi

        # 3. Check src/ directory if still nothing
        if [[ $count -eq 0 ]] && [[ -d "$source_node/src" ]]; then
          if [[ -f "$source_node/src/$meta_file" ]]; then
            local name=$(extract_meta_name "$source_node/src/$meta_file" "$(basename "$source_node")")
            mkdir -p "$target_dir/$name"
            cp -R "$source_node/src"/* "$target_dir/$name/"
            count=1
          fi
        fi

        if [[ $count -gt 0 ]]; then
          echo ""
          log_ok "Added skills from $owner/$repo to $(beautify_dir "$target_dir")"
        else
          # Show actual searched path
          local searched_dir="${source_node#$tmp_tool_node/$repo}"
          searched_dir="${searched_dir#/}"
          log_warn "No skill found organized in $owner/$repo${searched_dir:+/$searched_dir}"
        fi
      else
        log_error "Path not found: $path"
        rm -rf "$tmp_tool_node"
        return 1
      fi

      rm -rf "$tmp_tool_node"
    else
      rm -rf "$tmp_tool_node"
      log_error "Failed to clone: $clone_url"
      return 1
    fi
  fi
}

# Check if input is a GitHub reference
not_github_ref() {
  local input="$1"
  # Match: user/repo, https://github.com/user/repo, github.com/user/repo
  if [[ "$input" =~ ^https?://github\.com/ ]] \
    || [[ "$input" =~ ^github\.com/ ]] \
    || [[ "$input" =~ ^[a-zA-Z0-9_-]+/[a-zA-Z0-9_.-]+(/.*)?$ ]]; then
    return 1
  fi
  return 0
}

# Add skill to skills directory
add_skill() {
  local input="$1"

  if [[ -z "$input" ]]; then
    log_error "Usage: ai-global add <user/repo>"
    echo ""
    echo "Examples:"
    echo "  ai-global add user/repo"
    echo "  ai-global add https://github.com/user/repo"
    return 1
  fi

  # Check if it's a GitHub reference
  if not_github_ref "$input"; then
    log_error "Invalid input. Please provide a GitHub repository."
    echo ""
    echo "Examples:"
    echo "  ai-global add user/repo"
    echo "  ai-global add https://github.com/user/repo"
    return 1
  fi

  local base_dir="$(pwd)"
  log_context_info "$base_dir"

  local skills_dir="$base_dir/.ai-global/skills"
  mkdir -p "$skills_dir"
  download_from_github "skill" "$input" "$skills_dir"
}

# Upgrade
upgrade() {
  log_info "Checking for updates..."

  local remote_version
  remote_version=$(curl -fsSL "https://raw.githubusercontent.com/nanxiaobei/ai-global/main/ai-global" 2> /dev/null | grep '^VERSION=' | head -1 | sed 's/VERSION="\([^"]*\)"/\1/')

  if [[ -z "$remote_version" ]]; then
    log_warn "Could not check for updates"
    return 1
  fi

  if [[ "$remote_version" == "$VERSION" ]]; then
    log_ok "Already at latest version ($VERSION)"
    return 0
  fi

  log_info "Upgrading: $VERSION -> $remote_version"

  local current_script="$0"
  # If running via symlink, update the target
  if [[ -L "$current_script" ]]; then
    current_script=$(readlink "$current_script")
  fi

  local exec_temp=$(mktemp)
  if curl -fsSL "https://raw.githubusercontent.com/nanxiaobei/ai-global/main/ai-global" -o "$exec_temp" 2> /dev/null; then
    chmod +x "$exec_temp"
    mv "$exec_temp" "$current_script"

    log_ok "Upgraded to v$remote_version"
  else
    rm -f "$exec_temp"
    log_error "Failed to download update"
    return 1
  fi
}

# Backup all ai-global configurations to .agents directory
backup_to_agents_dir() {
  local base_dir="$1"
  local config_dir="$base_dir/.ai-global"

  if [[ ! -d "$config_dir" ]]; then
    return 0
  fi

  local config_backup_dir="$base_dir/.agents_ai-global"
  rm -rf "$config_backup_dir" 2> /dev/null

  # Backup all
  local types=("AGENTS.md" "skills" "rules" "agents" "commands")

  for type_node in "${types[@]}"; do
    if [[ -e "$config_dir/$type_node" ]]; then
      cp -r "$config_dir/$type_node" "$config_backup_dir/" 2> /dev/null
    fi
  done

  # Log backup result only if backup directory was created
  if [[ -d "$config_backup_dir" ]]; then
    log_ok "Backed up $(beautify_dir "$config_dir") to ${GREEN}$(beautify_dir "$config_backup_dir")${NC}"
  fi
}

# Uninstall
uninstall() {
  # Backup all configurations to .agents directory
  echo ""
  backup_to_agents_dir "$HOME"
  unlink_all_tools "$HOME"
  echo ""

  # Find and clean up all project configurations
  local projects_file="$HOME/.ai-global/projects"
  if [[ ! -f "$projects_file" ]]; then
    log_info "No project configurations found"
    echo ""
  else
    log_info "Checking for project configurations..."
    echo ""

    local project_count=0

    while IFS= read -r project_dir; do
      [[ -z "$project_dir" ]] && continue
      # Only process if project directory actually exists
      if [[ -d "$project_dir" ]]; then
        if [[ -d "$project_dir/.ai-global" ]]; then
          log_info "Found project: $(beautify_dir "$project_dir")"
          backup_to_agents_dir "$project_dir"

          (cd "$project_dir" && unlink_all_tools "$project_dir" 2> /dev/null || true)

          rm -rf "$project_dir/.ai-global"
          log_ok "Removed project configuration: $(beautify_dir "$project_dir/.ai-global")"
          echo ""

          ((project_count++))
        fi
      fi
    done < "$projects_file"

    if [[ $project_count -eq 0 ]]; then
      log_info "No project configurations found"
      echo ""
    fi
  fi

  [[ -L /usr/local/bin/ai-global ]] && rm -f /usr/local/bin/ai-global
  [[ -L "$HOME/.local/bin/ai-global" ]] && rm -f "$HOME/.local/bin/ai-global"

  rm -rf "$HOME/.ai-global"
  log_ok "Removed system configuration: $(beautify_dir "$HOME/.ai-global")"

  log_ok "AI Global uninstalled successfully"
  echo ""
}

# Show version
show_version() {
  echo "ai-global version $VERSION"
}

# Show help
show_help() {
  echo -e "${BLUE}AI Global: Unified AI Tools Configuration Manager${NC} v$VERSION"
  echo ""
  echo -e "${BLUE}USAGE:${NC}"
  echo -e "  ai-global [command]"
  echo ""
  echo -e "${BLUE}CORE COMMANDS:${NC}"
  echo -e "  ${GREEN}(default)${NC}           Scan, merge, update symlinks"
  echo -e "  ${GREEN}status${NC}              Show symlinks status"
  echo -e "  ${GREEN}list${NC}                List all supported AI tools"
  echo -e "  ${GREEN}backups${NC}             List available backups"
  echo -e "  ${GREEN}unlink <key>${NC}        Restore a tool's original config"
  echo -e "  ${GREEN}unlink all${NC}          Restore all tools"
  echo ""
  echo -e "${BLUE}RESOURCE MANAGEMENT:${NC}"
  echo -e "  ${GREEN}add <user/repo>${NC}     Add skills"
  echo ""
  echo -e "${BLUE}SYSTEM COMMANDS:${NC}"
  echo -e "  ${GREEN}upgrade${NC}             Upgrade to latest version"
  echo -e "  ${GREEN}uninstall${NC}           Completely remove ai-global"
  echo -e "  ${GREEN}version${NC}             Show version"
  echo -e "  ${GREEN}help${NC}                Show this help"
  echo ""
}

# Main
main() {
  local cmd="$1"

  # Handle empty command
  if [[ -z "$cmd" ]]; then
    cmd="update"
  fi

  case "$cmd" in
    update) update_links ;;
    status) show_status ;;
    list) list_tools ;;
    backups) list_backups ;;
    unlink) unlink_tool "$2" ;;
    add) add_skill "$2" ;;

    upgrade) upgrade ;;
    uninstall) uninstall ;;
    version | -v | --version) show_version ;;
    help | --help | -h) show_help ;;
    *)
      log_error "Unknown command: $cmd"
      show_help
      exit 1
      ;;
  esac
}

main "$@"
